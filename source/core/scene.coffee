# This system is mainly in charge of crawling the DOM, doing some initial cleanup,
# and building a tree of important elements for animation.

Take ["Mode", "Scope", "SVG", "Symbol"], (Mode, Scope, SVG, Symbol)->
  deprecations = ["controlPanel", "ctrlPanel", "navOverlay"]
  masks = []
  defs = {}
  
  
  Make "Scene", Scene =
    crawl: (elm)->
      cleanupIds elm
      tree = processElm elm
      if masks.length then console.log "Please remove these mask elements from your SVG:", masks...
      masks = null # Avoid dangling references
      defs = null # Avoid dangling references
      return tree
    
    build: (tree)->
      buildScopes tree, setups = []
      setup() for setup in setups by -1 # loop backwards, to set up children before parents
  
  
  cleanupIds = (elm)->
    return unless Mode.dev
    # By default, elements with an ID are added to the window object.
    # For the sake of better typo handling, we replace those references with a proxy.
    for element in elm.querySelectorAll "[id]"
      if window[element.id]?
        do (element)->
          handlers =
            get: ()-> console.log(element); throw "You forgot to use an @ when accessing the scope for this element ^^^"
            set: (val)-> console.log(element); throw "You forgot to use an @ when accessing the scope for this element ^^^"
          window[element.id] = new Proxy {}, handlers

  
  processElm = (elm)->
    tree =
      elm: elm
      sub: []
    
    childNodes = Array.prototype.slice.call elm.childNodes
    
    for childElm in childNodes
      
      if (childElm.id in deprecations)
        console.log "##{childElm.id} is obsolete. Please remove it from your FLA and re-export this SVG."
        elm.removeChild childElm
      
      # clipPath masks are generated by Flash to wrap text, for some reason
      else if childElm.tagName is "clipPath"
        elm.removeChild childElm
      
      else if childElm.tagName is "text"
        childElm.removeAttribute? "clip-path"
      
      else if childElm.id?.indexOf("Mask") > -1
        masks.push childElm.id
        elm.removeChild childElm
      
      else if childElm instanceof SVGGElement
        tree.sub.push processElm childElm
        
      else if childElm instanceof SVGUseElement
        # We make a clone of the use'd element in defs, so that we can reach in and change (eg) strokes/fills.
        defId = childElm.getAttribute "xlink:href"
        def = defs[defId] ?= SVG.defs.querySelector defId
        clone = def.cloneNode true
        elm.replaceChild clone, childElm
        def.parentNode.removeChild def if def.parentNode?
        
        if clone instanceof SVGGElement
          tree.sub.push processElm clone
    
    return tree
  
  
  # BUILD SCOPES ##################################################################################
  
  
  buildScopes = (tree, setups, parentScope = null)->
    props = parent: parentScope
    
    if tree.elm.id.replace(/_FL/g, "").length > 0
      props.id = tree.elm.id.replace /_FL/g, ""
    
    # This is a bit of a legacy hack, where symbols are given names in Flash so that our code can hook up with them.
    baseName = tree.elm.id?.split("_")[0]
    symbol = if baseName.indexOf("Line") > -1 or baseName.indexOf("line") is 0
      Symbol.forSymbolName "HydraulicLine"
    else if baseName.indexOf("Field") > -1 or baseName.indexOf("field") is 0
      Symbol.forSymbolName "HydraulicField"
    else
      Symbol.forInstanceName props.id
    
    symbol ?= ()-> {}
    
    scope = Scope tree.elm, symbol, props
    setups.push scope.setup.bind scope if scope.setup?
    buildScopes subTarget, setups, scope for subTarget in tree.sub
